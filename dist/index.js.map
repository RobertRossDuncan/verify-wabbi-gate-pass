{"version":3,"file":"index.js","sources":["../webpack://javascript-action/./getTicketKeys.js","../webpack://javascript-action/./index.js","../webpack://javascript-action/./node_modules/@actions/core/lib/command.js","../webpack://javascript-action/./node_modules/@actions/core/lib/core.js","../webpack://javascript-action/./node_modules/@actions/core/lib/file-command.js","../webpack://javascript-action/./node_modules/@actions/core/lib/utils.js","../webpack://javascript-action/./node_modules/bent/node_modules/is-stream/index.js","../webpack://javascript-action/./node_modules/bent/src/core.js","../webpack://javascript-action/./node_modules/bent/src/nodejs.js","../webpack://javascript-action/./node_modules/bytesish/browser.js","../webpack://javascript-action/./node_modules/bytesish/core.js","../webpack://javascript-action/./node_modules/bytesish/node.js","../webpack://javascript-action/./node_modules/caseless/index.js","../webpack://javascript-action/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://javascript-action/external \"crypto\"","../webpack://javascript-action/external \"fs\"","../webpack://javascript-action/external \"http\"","../webpack://javascript-action/external \"https\"","../webpack://javascript-action/external \"os\"","../webpack://javascript-action/external \"path\"","../webpack://javascript-action/external \"stream\"","../webpack://javascript-action/external \"url\"","../webpack://javascript-action/external \"zlib\"","../webpack://javascript-action/webpack/bootstrap","../webpack://javascript-action/webpack/runtime/compat","../webpack://javascript-action/webpack/startup"],"sourcesContent":["const bent = require('bent');\r\n\r\nconst getTicketKeys = async (jiraPrefixes, pullRequestTitle, pullRequestSource,\r\n\tcommitsUrl, githubToken) => {\r\n\r\n\t// Define regular expressions to obtain Jira Ticket IDs\r\n\tconst prefixes = jiraPrefixes.replace(/,/g, '|');\r\n\tconst ticketKeyAtBeginning = new RegExp(`^(${prefixes})-\\\\d+`, 'g');\r\n\tconst ticketKeyAnywhere = new RegExp(`\\\\b(${prefixes})-\\\\d+`, 'g');\r\n\r\n\tconst getCommits = bent(commitsUrl, 'GET', 'json');\r\n\r\n\tconst gitHeader = {\r\n\t\tAccept: 'application/vnd.github.v3+json',\r\n\t\t'User-Agent': 'node/12',\r\n\t\tAuthorization: `bearer ${githubToken}`\r\n\t};\r\n\r\n\ttry {\r\n\t\t// Retrieve commit messages and extract any Jira Ticket Keys\r\n\t\tlet commitsArray = await getCommits(null, null, gitHeader);\r\n\r\n\t\tlet ticketKeys = [];\r\n\t\tfor (let element of commitsArray) {\r\n\t\t\tlet ticketKeysInMessage = element.commit && element.commit.message ?\r\n\t\t\t\telement.commit.message.match(ticketKeyAnywhere) : undefined ;\r\n\t\t\tif (ticketKeysInMessage) {\r\n\t\t\t\tticketKeys = ticketKeys.concat(ticketKeysInMessage);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Get source branch, PR title and extract any Jira Ticket Keys\r\n\t\tlet ticketKeyInSource = pullRequestSource.match(ticketKeyAtBeginning);\r\n\t\tif (ticketKeyInSource) {\r\n\t\t\tticketKeys = ticketKeys.concat(ticketKeyInSource);\r\n\t\t}\r\n\t\tlet ticketKeyInTitle = pullRequestTitle.match(ticketKeyAtBeginning);\r\n\t\tif (ticketKeyInTitle) {\r\n\t\t\tticketKeys = ticketKeys.concat(ticketKeyInTitle);\r\n\t\t}\r\n\t\treturn [...new Set(ticketKeys)];\r\n\t}\r\n\tcatch (error) {\r\n\t\tthrow new Error(`Failed to obtain ticket keys ${error.message}`);\r\n\t}\r\n};\r\n\r\nmodule.exports = getTicketKeys;","const core = require('@actions/core');\r\nconst github = require('@actions/github');\r\n\r\nconst getTicketKeys = require('./getTicketKeys');\r\nconst getWabbiGatePass = require('./getTicketKeys');\r\n\r\nconst GATE_PASSED = 'Associated Wabbi Gate Passed';\r\nconst GATE_FAILED = 'Associated Wabbi Gate Failed';\r\n\r\n// Function determining Wabbi Gate Status of associated pull request\r\nconst processPullRequestEvent = async (pullRequest) => {\r\n\t// Obtain pull request information\r\n\tconst commitsUrl = pullRequest._links.commits.href;\r\n\tconst pullRequestSource = pullRequest.head.ref;\r\n\tconst pullRequestTitle = pullRequest.title;\r\n\r\n\t// Obtain wabbi configuration info\r\n\tconst wabbiHost = core.getInput('wabbiHost');\r\n\tconst wabbiProjectId = core.getInput('wabbiProjectId');\r\n\tconst jiraPrefixes = core.getInput('jiraPrefixes');\r\n\tconst wabbiGateId = core.getInput('wabbiGateId');\r\n\tconst wabbiGateToken = core.getInput('wabbiGateToken');\r\n\r\n\t// Obtain github access info\r\n\tconst githubToken = core.getInput('githubToken');\r\n\r\n\t// Debug Remove the following debug code before release\r\n\tconsole.log(`The PR commits url is ${commitsUrl}`);\r\n\tconsole.log(`The PR source is ${pullRequestSource}`);\r\n\tconsole.log(`The PR title is ${pullRequestTitle}`);\r\n\t// Debug Remove the above debug code before release\r\n\r\n\ttry {\r\n\t\t// Get Jira ticket keys associated with the pull request\r\n\t\tlet ticketKeys = await getTicketKeys(jiraPrefixes,\r\n\t\t\tpullRequestTitle,\r\n\t\t\tpullRequestSource,\r\n\t\t\tcommitsUrl,\r\n\t\t\tgithubToken);\r\n\r\n\t\t// Obtain the Wabbi Gate status associated with ticket keys\r\n\t\tlet gateStatus = await getWabbiGatePass(wabbiHost,\r\n\t\t\twabbiGateToken,\r\n\t\t\twabbiProjectId,\r\n\t\t\twabbiGateId,\r\n\t\t\tticketKeys);\r\n\r\n\t\t// Based on wabbi gate status process PR\r\n\t\tif (gateStatus) {\r\n\t\t\tcore.setOutput('status', GATE_PASSED);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcore.setOutput('status', GATE_FAILED);\r\n\t\t\tcore.setFailed(GATE_FAILED);\r\n\t\t}\r\n\t}\r\n\tcatch (error) {\r\n\t\tcore.setFailed(error.message);\r\n\t}\r\n};\r\n\r\n// Driver function to handle async calls\r\nPromise.resolve(\r\n\tprocessPullRequestEvent(\r\n\t\tgithub.context.payload.number,\r\n\t\tgithub.context.payload.pull_request\r\n\t)\r\n);\r\n","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.  The value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","'use strict';\n\nconst isStream = stream =>\n\tstream !== null &&\n\ttypeof stream === 'object' &&\n\ttypeof stream.pipe === 'function';\n\nisStream.writable = stream =>\n\tisStream(stream) &&\n\tstream.writable !== false &&\n\ttypeof stream._write === 'function' &&\n\ttypeof stream._writableState === 'object';\n\nisStream.readable = stream =>\n\tisStream(stream) &&\n\tstream.readable !== false &&\n\ttypeof stream._read === 'function' &&\n\ttypeof stream._readableState === 'object';\n\nisStream.duplex = stream =>\n\tisStream.writable(stream) &&\n\tisStream.readable(stream);\n\nisStream.transform = stream =>\n\tisStream.duplex(stream) &&\n\ttypeof stream._transform === 'function';\n\nmodule.exports = isStream;\n","'use strict'\nconst encodings = new Set(['json', 'buffer', 'string'])\n\nmodule.exports = mkrequest => (...args) => {\n  const statusCodes = new Set()\n  let method\n  let encoding\n  let headers\n  let baseurl = ''\n\n  args.forEach(arg => {\n    if (typeof arg === 'string') {\n      if (arg.toUpperCase() === arg) {\n        if (method) {\n          const msg = `Can't set method to ${arg}, already set to ${method}.`\n          throw new Error(msg)\n        } else {\n          method = arg\n        }\n      } else if (arg.startsWith('http:') || arg.startsWith('https:')) {\n        baseurl = arg\n      } else {\n        if (encodings.has(arg)) {\n          encoding = arg\n        } else {\n          throw new Error(`Unknown encoding, ${arg}`)\n        }\n      }\n    } else if (typeof arg === 'number') {\n      statusCodes.add(arg)\n    } else if (typeof arg === 'object') {\n      if (Array.isArray(arg) || arg instanceof Set) {\n        arg.forEach(code => statusCodes.add(code))\n      } else {\n        if (headers) {\n          throw new Error('Cannot set headers twice.')\n        }\n        headers = arg\n      }\n    } else {\n      throw new Error(`Unknown type: ${typeof arg}`)\n    }\n  })\n\n  if (!method) method = 'GET'\n  if (statusCodes.size === 0) {\n    statusCodes.add(200)\n  }\n\n  return mkrequest(statusCodes, method, encoding, headers, baseurl)\n}\n","'use strict'\nconst http = require('http')\nconst https = require('https')\nconst { URL } = require('url')\nconst isStream = require('is-stream')\nconst caseless = require('caseless')\nconst bytes = require('bytesish')\nconst bent = require('./core')\nconst zlib = require('zlib')\nconst { PassThrough } = require('stream')\n\nconst compression = {}\n\n/* istanbul ignore else */\nif (zlib.createBrotliDecompress) compression.br = () => zlib.createBrotliDecompress()\n/* istanbul ignore else */\nif (zlib.createGunzip) compression.gzip = () => zlib.createGunzip()\n/* istanbul ignore else */\nif (zlib.createInflate) compression.deflate = () => zlib.createInflate()\n\nconst acceptEncoding = Object.keys(compression).join(', ')\n\nconst getResponse = resp => {\n  const ret = new PassThrough()\n  ret.statusCode = resp.statusCode\n  ret.status = resp.statusCode\n  ret.statusMessage = resp.statusMessage\n  ret.headers = resp.headers\n  ret._response = resp\n  if (ret.headers['content-encoding']) {\n    const encodings = ret.headers['content-encoding'].split(', ').reverse()\n    while (encodings.length) {\n      const enc = encodings.shift()\n      if (compression[enc]) {\n        const decompress = compression[enc]()\n        decompress.on('error', (e) => ret.emit('error', new Error('ZBufError', e)))\n        resp = resp.pipe(decompress)\n      } else {\n        break\n      }\n    }\n  }\n  return resp.pipe(ret)\n}\n\nclass StatusError extends Error {\n  constructor (res, ...params) {\n    super(...params)\n\n    Error.captureStackTrace(this, StatusError)\n    this.name = 'StatusError'\n    this.message = res.statusMessage\n    this.statusCode = res.statusCode\n    this.json = res.json\n    this.text = res.text\n    this.arrayBuffer = res.arrayBuffer\n    this.headers = res.headers\n    let buffer\n    const get = () => {\n      if (!buffer) buffer = this.arrayBuffer()\n      return buffer\n    }\n    Object.defineProperty(this, 'responseBody', { get })\n  }\n}\n\nconst getBuffer = stream => new Promise((resolve, reject) => {\n  const parts = []\n  stream.on('error', reject)\n  stream.on('end', () => resolve(Buffer.concat(parts)))\n  stream.on('data', d => parts.push(d))\n})\n\nconst decodings = res => {\n  let _buffer\n  res.arrayBuffer = () => {\n    if (!_buffer) {\n      _buffer = getBuffer(res)\n      return _buffer\n    } else {\n      throw new Error('body stream is locked')\n    }\n  }\n  res.text = () => res.arrayBuffer().then(buff => buff.toString())\n  res.json = async () => {\n    const str = await res.text()\n    try {\n      return JSON.parse(str)\n    } catch (e) {\n      e.message += `str\"${str}\"`\n      throw e\n    }\n  }\n}\n\nconst mkrequest = (statusCodes, method, encoding, headers, baseurl) => (_url, body = null, _headers = {}) => {\n  _url = baseurl + (_url || '')\n  const parsed = new URL(_url)\n  let h\n  if (parsed.protocol === 'https:') {\n    h = https\n  } else if (parsed.protocol === 'http:') {\n    h = http\n  } else {\n    throw new Error(`Unknown protocol, ${parsed.protocol}`)\n  }\n  const request = {\n    path: parsed.pathname + parsed.search,\n    port: parsed.port,\n    method: method,\n    headers: { ...(headers || {}), ..._headers },\n    hostname: parsed.hostname\n  }\n  if (parsed.username || parsed.password) {\n    request.auth = [parsed.username, parsed.password].join(':')\n  }\n  const c = caseless(request.headers)\n  if (encoding === 'json') {\n    if (!c.get('accept')) {\n      c.set('accept', 'application/json')\n    }\n  }\n  if (!c.has('accept-encoding')) {\n    c.set('accept-encoding', acceptEncoding)\n  }\n  return new Promise((resolve, reject) => {\n    const req = h.request(request, async res => {\n      res = getResponse(res)\n      res.on('error', reject)\n      decodings(res)\n      res.status = res.statusCode\n      if (!statusCodes.has(res.statusCode)) {\n        return reject(new StatusError(res))\n      }\n\n      if (!encoding) return resolve(res)\n      else {\n        /* istanbul ignore else */\n        if (encoding === 'buffer') {\n          resolve(res.arrayBuffer())\n        } else if (encoding === 'json') {\n          resolve(res.json())\n        } else if (encoding === 'string') {\n          resolve(res.text())\n        }\n      }\n    })\n    req.on('error', reject)\n    if (body) {\n      if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n        body = bytes.native(body)\n      }\n      if (Buffer.isBuffer(body)) {\n        // noop\n      } else if (typeof body === 'string') {\n        body = Buffer.from(body)\n      } else if (isStream(body)) {\n        body.pipe(req)\n        body = null\n      } else if (typeof body === 'object') {\n        if (!c.has('content-type')) {\n          req.setHeader('content-type', 'application/json')\n        }\n        body = Buffer.from(JSON.stringify(body))\n      } else {\n        reject(new Error('Unknown body type.'))\n      }\n      if (body) {\n        req.setHeader('content-length', body.length)\n        req.end(body)\n      }\n    } else {\n      req.end()\n    }\n  })\n}\n\nmodule.exports = bent(mkrequest)\n","/* globals atob, btoa, crypto */\n/* istanbul ignore file */\n'use strict'\nconst bytes = require('./core')\n\nbytes.from = (_from, _encoding) => {\n  if (_from instanceof DataView) return _from\n  if (_from instanceof ArrayBuffer) return new DataView(_from)\n  let buffer\n  if (typeof _from === 'string') {\n    if (!_encoding) {\n      _encoding = 'utf-8'\n    } else if (_encoding === 'base64') {\n      buffer = Uint8Array.from(atob(_from), c => c.charCodeAt(0)).buffer\n      return new DataView(buffer)\n    }\n    if (_encoding !== 'utf-8') throw new Error('Browser support for encodings other than utf-8 not implemented')\n    return new DataView((new TextEncoder()).encode(_from).buffer)\n  } else if (typeof _from === 'object') {\n    if (ArrayBuffer.isView(_from)) {\n      if (_from.byteLength === _from.buffer.byteLength) return new DataView(_from.buffer)\n      else return new DataView(_from.buffer, _from.byteOffset, _from.byteLength)\n    }\n  }\n  throw new Error('Unkown type. Cannot convert to ArrayBuffer')\n}\n\nbytes.toString = (_from, encoding) => {\n  _from = bytes(_from, encoding)\n  const uint = new Uint8Array(_from.buffer, _from.byteOffset, _from.byteLength)\n  const str = String.fromCharCode(...uint)\n  if (encoding === 'base64') {\n    /* would be nice to find a way to do this directly from a buffer\n     * instead of doing two string conversions\n     */\n    return btoa(str)\n  } else {\n    return str\n  }\n}\n\nbytes.native = (_from, encoding) => {\n  if (_from instanceof Uint8Array) return _from\n  _from = bytes.from(_from, encoding)\n  return new Uint8Array(_from.buffer, _from.byteOffset, _from.byteLength)\n}\n\nif (process.browser) bytes._randomFill = (...args) => crypto.getRandomValues(...args)\n\nmodule.exports = bytes\n","'use strict'\n\nconst length = (a, b) => {\n  if (a.byteLength === b.byteLength) return a.byteLength\n  else if (a.byteLength > b.byteLength) return a.byteLength\n  return b.byteLength\n}\n\nconst bytes = (_from, encoding) => bytes.from(_from, encoding)\n\nbytes.sorter = (a, b) => {\n  a = bytes(a)\n  b = bytes(b)\n  const len = length(a, b)\n  let i = 0\n  while (i < (len - 1)) {\n    if (i >= a.byteLength) return 1\n    else if (i >= b.byteLength) return -1\n\n    if (a.getUint8(i) < b.getUint8(i)) return -1\n    else if (a.getUint8(i) > b.getUint8(i)) return 1\n    i++\n  }\n  return 0\n}\n\nbytes.compare = (a, b) => !bytes.sorter(a, b)\nbytes.memcopy = (_from, encoding) => {\n  const b = bytes(_from, encoding)\n  return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength)\n}\nbytes.arrayBuffer = (_from, encoding) => {\n  _from = bytes(_from, encoding)\n  if (_from.buffer.byteLength === _from.byteLength) return _from.buffer\n  return _from.buffer.slice(_from.byteOffset, _from.byteOffset + _from.byteLength)\n}\nconst sliceOptions = (_from, start = 0, end = null) => {\n  _from = bytes(_from)\n  end = (end === null ? _from.byteLength : end) - start\n  return [_from.buffer, _from.byteOffset + start, end]\n}\nbytes.slice = (_from, start, end) => new DataView(...sliceOptions(_from, start, end))\n\nbytes.memcopySlice = (_from, start, end) => {\n  const [buffer, offset, length] = sliceOptions(_from, start, end)\n  return buffer.slice(offset, length + offset)\n}\nbytes.typedArray = (_from, _Class = Uint8Array) => {\n  _from = bytes(_from)\n  return new _Class(_from.buffer, _from.byteOffset, _from.byteLength / _Class.BYTES_PER_ELEMENT)\n}\n\nbytes.concat = (_from) => {\n  _from = Array.from(_from)\n  _from = _from.map(b => bytes(b))\n  const length = _from.reduce((x, y) => x + y.byteLength, 0)\n  const ret = new Uint8Array(length)\n  let i = 0\n  for (const part of _from) {\n    const view = bytes.typedArray(part)\n    ret.set(view, i)\n    i += view.byteLength\n  }\n  return ret.buffer\n}\n\nconst maxEntropy = 65536\n\nbytes.random = length => {\n  const ab = new ArrayBuffer(length)\n  if (length > maxEntropy) {\n    let i = 0\n    while (i < ab.byteLength) {\n      let len\n      if (i + maxEntropy > ab.byteLength) len = ab.byteLength - i\n      else len = maxEntropy\n      const view = new Uint8Array(ab, i, len)\n      i += maxEntropy\n      bytes._randomFill(view)\n    }\n  } else {\n    const view = new Uint8Array(ab)\n    bytes._randomFill(view)\n  }\n  return ab\n}\n\nmodule.exports = bytes\n","'use strict'\nconst crypto = require('crypto')\nconst fallback = require('./browser').from\nconst bytes = require('./core')\n\nbytes.from = (_from, encoding) => {\n  if (_from instanceof DataView) return _from\n  if (_from instanceof ArrayBuffer) return new DataView(_from)\n  if (typeof _from === 'string') {\n    _from = Buffer.from(_from, encoding)\n  }\n  if (Buffer.isBuffer(_from)) {\n    return new DataView(_from.buffer, _from.byteOffset, _from.byteLength)\n  }\n  return fallback(_from, encoding)\n}\nbytes.toString = (_from, encoding) => {\n  _from = bytes(_from)\n  return Buffer.from(_from.buffer, _from.byteOffset, _from.byteLength).toString(encoding)\n}\n\nbytes.native = (_from, encoding) => {\n  if (Buffer.isBuffer(_from)) return _from\n  _from = bytes(_from, encoding)\n  return Buffer.from(_from.buffer, _from.byteOffset, _from.byteLength)\n}\n\nbytes._randomFill = crypto.randomFillSync\n\nmodule.exports = bytes\n","function Caseless (dict) {\n  this.dict = dict || {}\n}\nCaseless.prototype.set = function (name, value, clobber) {\n  if (typeof name === 'object') {\n    for (var i in name) {\n      this.set(i, name[i], value)\n    }\n  } else {\n    if (typeof clobber === 'undefined') clobber = true\n    var has = this.has(name)\n\n    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value\n    else this.dict[has || name] = value\n    return has\n  }\n}\nCaseless.prototype.has = function (name) {\n  var keys = Object.keys(this.dict)\n    , name = name.toLowerCase()\n    ;\n  for (var i=0;i<keys.length;i++) {\n    if (keys[i].toLowerCase() === name) return keys[i]\n  }\n  return false\n}\nCaseless.prototype.get = function (name) {\n  name = name.toLowerCase()\n  var result, _key\n  var headers = this.dict\n  Object.keys(headers).forEach(function (key) {\n    _key = key.toLowerCase()\n    if (name === _key) result = headers[key]\n  })\n  return result\n}\nCaseless.prototype.swap = function (name) {\n  var has = this.has(name)\n  if (has === name) return\n  if (!has) throw new Error('There is no header than matches \"'+name+'\"')\n  this.dict[name] = this.dict[has]\n  delete this.dict[has]\n}\nCaseless.prototype.del = function (name) {\n  var has = this.has(name)\n  return delete this.dict[has || name]\n}\n\nmodule.exports = function (dict) {return new Caseless(dict)}\nmodule.exports.httpify = function (resp, headers) {\n  var c = new Caseless(headers)\n  resp.setHeader = function (key, value, clobber) {\n    if (typeof value === 'undefined') return\n    return c.set(key, value, clobber)\n  }\n  resp.hasHeader = function (key) {\n    return c.has(key)\n  }\n  resp.getHeader = function (key) {\n    return c.get(key)\n  }\n  resp.removeHeader = function (key) {\n    return c.del(key)\n  }\n  resp.headers = c.dict\n  return c\n}\n",null,"module.exports = require(\"crypto\");;","module.exports = require(\"fs\");;","module.exports = require(\"http\");;","module.exports = require(\"https\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","module.exports = require(\"stream\");;","module.exports = require(\"url\");;","module.exports = require(\"zlib\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(932);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACpEA;AACA;AACA;A;;;;;;ACFA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}